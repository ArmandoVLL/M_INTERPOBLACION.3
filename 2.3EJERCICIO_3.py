# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18rdan_eLgiprF4QbvVFKic7tAWkDB_0z
"""

# Código que interpola una función y encuentra su raíz usando bisección
#
# Autor: Armando Augusto Valladares Uc
# Versión 1.01 : 17/02/2025

import numpy as np  # Operaciones numéricas
import matplotlib.pyplot as plt  # Generación de gráficos

# Definir la función f(x) = e^(-x) - x
def f(x):
    return np.exp(-x) - x

# Interpolación de Lagrange
def lagrange_interpolation(x, x_puntos, y_puntos):
    P_Interpolacion = len(x_puntos)  # Número de puntos
    Resultado = 0
    for i in range(P_Interpolacion):
        termino_Lag = y_puntos[i]
        for j in range(P_Interpolacion):
            if i != j:
                termino_Lag *= (x - x_puntos[j]) / (x_puntos[i] - x_puntos[j])
        Resultado += termino_Lag
    return Resultado

# Método de bisección para encontrar la raíz
def bisect(func, a, b, tol=1e-6, max_iter=100):
    if func(a) * func(b) > 0:
        raise ValueError("El intervalo no contiene una raíz")
    for _ in range(max_iter):
        c = (a + b) / 2
        if abs(func(c)) < tol or (b - a) / 2 < tol:
            return c
        if func(a) * func(c) < 0:
            b = c
        else:
            a = c
    return (a + b) / 2

# Selección de puntos de interpolación en [0,1]
x_points = np.array([0.0, 0.25, 0.5, 1.0])
y_points = f(x_points)

# Construcción del polinomio interpolante
x_vals = np.linspace(0, 1, 100)
y_interp = [lagrange_interpolation(x, x_points, y_points) for x in x_vals]

# Encontrar raíz aproximada del polinomio interpolante
root = bisect(lambda x: lagrange_interpolation(x, x_points, y_points), 0, 1)

# Cálculo de errores
errores_absolutos = np.abs(y_interp - f(x_vals))
errores_relativos = errores_absolutos / np.where(np.abs(f(x_vals)) == 0, 1, np.abs(f(x_vals)))
errores_cuadraticos = errores_absolutos**2

# Imprimir tabla de errores
print(f"{'Iteración':<10}|{'x':<12}|{'Error absoluto':<18}|{'Error relativo':<18}|{'Error cuadrático'}")
print("-" * 80)
for i, (x_val, error_abs, error_rel, error_cuad) in enumerate(zip(x_vals, errores_absolutos, errores_relativos, errores_cuadraticos)):
    print(f"{i+1:<10}|{x_val:<12.6f}|{error_abs:<18.6e}|{error_rel:<18.6e}|{error_cuad:.6e}")

# Generar gráficos
fig, ax = plt.subplots(1, 2, figsize=(14, 5))

# Gráfica de errores
ax[0].plot(x_vals, errores_absolutos, label="Error Absoluto", color='purple')
ax[0].plot(x_vals, errores_relativos, label="Error Relativo", color='orange')
ax[0].plot(x_vals, errores_cuadraticos, label="Error Cuadrático", color='brown')
ax[0].set_xlabel("x")
ax[0].set_ylabel("Errores")
ax[0].legend()
ax[0].grid(True)

# Gráfica de la función e interpolación
ax[1].plot(x_vals, f(x_vals), label="f(x) = e^(-x) - x", linestyle='dashed', color='blue')
ax[1].plot(x_vals, y_interp, label="Interpolación de Lagrange", color='red')
ax[1].axhline(0, color='black', linewidth=0.5, linestyle='--')
ax[1].axvline(root, color='green', linestyle='dotted', label=f"Raíz: {root:.4f}")
ax[1].scatter(x_points, y_points, color='black', label="Puntos de interpolación")
ax[1].set_xlabel("x")
ax[1].set_ylabel("f(x)")
ax[1].legend()
ax[1].grid(True)

# Guardar y mostrar la gráfica
plt.savefig("interpolacion_raices.png")
plt.show()

# Imprimir la raíz encontrada
print(f"Raíz aproximada: {root:.4f}")